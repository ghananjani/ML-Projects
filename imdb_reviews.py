# -*- coding: utf-8 -*-
"""IMDB Reviews.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rXlFAmMwvaS_NHwU0TsAHZ8EkoxJWK_q

Data Preprocessing
"""

import pandas as pd

from google.colab import drive

drive.mount('/content/drive')

data = pd.read_csv("/content/drive/MyDrive/IMDB Dataset.csv")

print(data.head(10))

print(data.tail(10))

"""Split dataset into training and testing dataset"""

train_data = data[:25000]
test_data = data[25000:]

"""Feature Extraction"""

from sklearn.feature_extraction.text import TfidfVectorizer

tfidf_vectorizer = TfidfVectorizer(stop_words='english')

X_train = tfidf_vectorizer.fit_transform(train_data['review'])
y_train = train_data['sentiment']

X_test = tfidf_vectorizer.transform(test_data['review'])
y_test = test_data['sentiment']

"""Model Building"""

from sklearn.linear_model import LogisticRegression

model = LogisticRegression(max_iter=1000)

model.fit(X_train, y_train)

"""Model Evaluation"""

from sklearn.metrics import accuracy_score, classification_report

y_pred = model.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)
print("Classification Report:")
print(classification_report(y_test, y_pred))

"""Prediction"""

# Convert elements in y_pred to integers, considering 'positive' as 1 and 'negative' as 0
y_pred_int = [1 if pred == 'positive' else 0 if pred == 'negative' else int(pred) for pred in y_pred]

# Calculate the number of positive and negative reviews
positive_reviews = sum(y_pred_int)
negative_reviews = len(y_pred_int) - positive_reviews

# Print the results
print("Number of positive reviews predicted:", positive_reviews)
print("Number of negative reviews predicted:", negative_reviews)

"""Data Visualisation"""

import matplotlib.pyplot as plt

# Data
review_labels = ['Positive', 'Negative']
review_counts = [positive_reviews, negative_reviews]

# Create bar graph
plt.bar(review_labels, review_counts, color=['green', 'red'])
plt.xlabel('Review Sentiment')
plt.ylabel('Number of Reviews')
plt.title('Number of Positive and Negative Reviews')
plt.show()

# Pie chart
plt.pie(review_counts, labels=review_labels, colors=['green', 'red'], autopct='%1.1f%%', startangle=140)
plt.title('Proportion of Positive and Negative Reviews')
plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
plt.show()

# Assuming you have numerical review scores
import numpy as np

# Generate some example data
np.random.seed(0)
scores_positive = np.random.normal(loc=4, scale=1, size=1000)
scores_negative = np.random.normal(loc=2, scale=1, size=1000)

# Create histogram
plt.hist(scores_positive, bins=20, alpha=0.5, label='Positive Reviews')
plt.hist(scores_negative, bins=20, alpha=0.5, label='Negative Reviews')
plt.xlabel('Review Score')
plt.ylabel('Frequency')
plt.title('Distribution of Review Scores')
plt.legend()
plt.show()

# Assuming you have time series data
import matplotlib.dates as mdates

# Generate some example dates
dates = pd.date_range(start='2024-01-01', end='2024-01-10')
# Example data, replace with your actual data
positive_counts = [10, 15, 20, 25, 30, 35, 40, 45, 50, 55]
negative_counts = [5, 8, 12, 18, 22, 26, 30, 35, 40, 45]

plt.plot(dates, positive_counts, label='Positive', marker='o')
plt.plot(dates, negative_counts, label='Negative', marker='o')
plt.xlabel('Date')
plt.ylabel('Number of Reviews')
plt.title('Number of Positive and Negative Reviews Over Time')
plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
plt.gca().xaxis.set_major_locator(mdates.DayLocator(interval=1))
plt.xticks(rotation=45)
plt.legend()
plt.tight_layout()
plt.show()